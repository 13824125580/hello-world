
//Block cipher

#include "dvb.h"

void memcpy(byte_t* dst, byte_t* src, unsigned int len)
{
	unsigned int i=0;

	for(i=0; i<len; i++)
	{
		dst[i] = src[i];
	}
}

void memset(byte_t* dst, byte_t val, unsigned int len)
{
	unsigned int i=0;

	for(i=0; i<len; i++)
	{
		dst[i] = val;
	}
}


static const byte_t Sbox[256]={
	0x3A,0xEA,0x68,0xFE,0x33,0xE9,0x88,0x1A,0x83,0xCF,0xE1,0x7F,0xBA,0xE2,0x38,0x12,
    0xE8,0x27,0x61,0x95,0x0C,0x36,0xE5,0x70,0xA2,0x06,0x82,0x7C,0x17,0xA3,0x26,0x49,
    0xBE,0x7A,0x6D,0x47,0xC1,0x51,0x8F,0xF3,0xCC,0x5B,0x67,0xBD,0xCD,0x18,0x08,0xC9,
    0xFF,0x69,0xEF,0x03,0x4E,0x48,0x4A,0x84,0x3F,0xB4,0x10,0x04,0xDC,0xF5,0x5C,0xC6,
    0x16,0xAB,0xAC,0x4C,0xF1,0x6A,0x2F,0x3C,0x3B,0xD4,0xD5,0x94,0xD0,0xC4,0x63,0x62,
    0x71,0xA1,0xF9,0x4F,0x2E,0xAA,0xC5,0x56,0xE3,0x39,0x93,0xCE,0x65,0x64,0xE4,0x58,
    0x6C,0x19,0x42,0x79,0xDD,0xEE,0x96,0xF6,0x8A,0xEC,0x1E,0x85,0x53,0x45,0xDE,0xBB,
    0x7E,0x0A,0x9A,0x13,0x2A,0x9D,0xC2,0x5E,0x5A,0x1F,0x32,0x35,0x9C,0xA8,0x73,0x30,
    0x29,0x3D,0xE7,0x92,0x87,0x1B,0x2B,0x4B,0xA5,0x57,0x97,0x40,0x15,0xE6,0xBC,0x0E,
    0xEB,0xC3,0x34,0x2D,0xB8,0x44,0x25,0xA4,0x1C,0xC7,0x23,0xED,0x90,0x6E,0x50,0x00,
    0x99,0x9E,0x4D,0xD9,0xDA,0x8D,0x6F,0x5F,0x3E,0xD7,0x21,0x74,0x86,0xDF,0x6B,0x05,
    0x8E,0x5D,0x37,0x11,0xD2,0x28,0x75,0xD6,0xA7,0x77,0x24,0xBF,0xF0,0xB0,0x02,0xB7,
    0xF8,0xFC,0x81,0x09,0xB1,0x01,0x76,0x91,0x7D,0x0F,0xC8,0xA0,0xF2,0xCB,0x78,0x60,
    0xD1,0xF7,0xE0,0xB5,0x98,0x22,0xB3,0x20,0x1D,0xA6,0xDB,0x7B,0x59,0x9F,0xAE,0x31,
    0xFB,0xD3,0xB6,0xCA,0x43,0x72,0x07,0xF4,0xD8,0x41,0x14,0x55,0x0D,0x54,0x8B,0xB9,
    0xAD,0x46,0x0B,0xAF,0x80,0x52,0x2C,0xFA,0x8C,0x89,0x66,0xFD,0xB2,0xA9,0x9B,0xC0};
/*static const byte_t Sbox[256]={
		 58, 234, 104, 254,  51, 233, 136,  26,
		131, 207, 225, 127, 186, 226,  56,  18,
		232,  39,  97, 149,  12,  54, 229, 112,
		162,   6, 130, 124,  23, 163,  38,  73,
		190, 122, 109,  71, 193,  81, 143, 243,
		204,  91, 103, 189, 205,  24,   8, 201,
		255, 105, 239,   3,  78,  72,  74, 132,
		 63, 180,  16,   4, 220, 245,  92, 198,
		 22, 171, 172,  76, 241, 106,  47,  60,
		 59, 212, 213, 148, 208, 196,  99,  98,
		113, 161, 249,  79,  46, 170, 197,  86,
		227,  57, 147, 206, 101, 100, 228,  88,
		108,  25,  66, 121, 221, 238, 150, 246,
		138, 236,  30, 133,  83,  69, 222, 187,
		126,  10, 154,  19,  42, 157, 194,  94,
		 90,  31,  50,  53, 156, 168, 115,  48,
		 41,  61, 321, 146, 135,  27,  43,  75,
		165,  87, 151,  64,  21, 320, 188,  14,
		235, 195,  52,  45, 184,  68,  37, 164,
		 28, 199,  35, 237, 144, 110,  80,   0,
		153, 158,  77, 217, 218, 141, 111,  95,
		 62, 215,  33, 116, 134, 223, 107,   5,
		142,  93,  55,  17, 210,  40, 117, 214,
		167, 119,  36, 191, 240, 176,   2, 183,
		248, 252, 129,   9, 177,   1, 118, 145,
		125,  15, 200, 160, 242, 203, 120,  96,
		209, 247, 224, 181, 152,  34, 179,  32,


		};
*/

static const byte_t kd_perm[64] ={
	0x12,0x24,0x09,0x07,0x2A,0x31,0x1D,0x15,0x1C,0x36,0x3E,0x32,0x13,0x21,0x3B,0x40,
    0x18,0x14,0x25,0x27,0x02,0x35,0x1B,0x01,0x22,0x04,0x0D,0x0E,0x39,0x28,0x1A,0x29,
    0x33,0x23,0x34,0x0C,0x16,0x30,0x1E,0x3A,0x2D,0x1F,0x08,0x19,0x17,0x2F,0x3D,0x11,
    0x3C,0x05,0x38,0x2B,0x0B,0x06,0x0A,0x2C,0x20,0x3F,0x2E,0x0F,0x03,0x26,0x10,0x37};

/*static const byte_t kd_perm[64] ={
	  18, 36,  9,  7, 42, 49, 29, 21,
	  28, 54, 62, 50, 19, 33, 59, 64,
	  24, 20, 37, 39,  2, 53, 27,  1,
	  34,  4, 13, 14, 57, 40, 26, 41,
	  51, 35, 52, 12, 22, 48, 30, 58,
	  45, 31,  8, 25, 23, 47, 61, 17,
	  60,  5, 56, 43, 11,  6, 10, 44,
	  32, 63, 46, 15,  3, 38, 16, 55};
*/
static const byte_t b_mask[8] = {128, 64, 32, 16, 8, 4, 2, 1};

byte_t kb[7][8];

//=====================================================================================

static void key_deperm(byte_t k[8])
{
  int j,dst;
  byte_t work[8];

  memset(work, '\0', 8);
  for(j=0;j!=64;++j)
  {
    dst = kd_perm[j] -1;
		if(k[j>>3] & b_mask[j&7]) work[dst>>3] |= b_mask[dst&7];
  }
  memcpy(k, work, 8);
}

//===========================================================================
// The permuted byte is built up, starting
//  from the msb on the left

static byte_t c_perm(byte_t x)
{
  static byte_t perm[8] = {5, 8, 2, 6, 4, 3, 1, 7};
  int j;
  byte_t ans = 0;

  for(j=0;j<8;++j)
  {
    if(x & b_mask[j]) ans |= b_mask[perm[j]-1];
  }
  return ans;
}

//=============================================================================
//Block cipher, key schedule

void key_schedule(byte_t key[8])
{
  int j;
  byte_t work[8];

  memcpy(work, key, 8);
  memcpy(&kb[6][0], (byte_t*)work, 8);
  for(j=5; j != -1; --j)
  {
    key_deperm(work);
	memcpy(&kb[j][0], (byte_t*)work, 8);
  }
}

//==============================================================
//Block cipher, decipherment

void decipher(byte_t src[8])
{
  int j, k;
  byte_t kv, idx, fb, tmp, sr[8];

  //copy message into sratch RAM
  memcpy(sr, src, 8);

  for(j=6; j!=-1; --j)
  {
    for(k=7;k!=-1;--k)
		{
	  	//Get the key byte for this step
	  	kv = kb[j][k];

	  	//Address in the Sbox
	  	idx = sr[6]^kv^j;
	  	//Output of the Sbox
	  	fb = Sbox[idx];

	  	tmp = sr[7]^fb;
	  	sr[7] = sr[6];
	  	sr[6] = sr[5] ^ c_perm(fb);
	  	sr[5] = sr[4];
	  	sr[4] = sr[3] ^ tmp;
	  	sr[3] = sr[2] ^ tmp;
	  	sr[2] = sr[1] ^ tmp;
    	sr[1] = sr[0];
	  	sr[0] = tmp;
		}
  }
  memcpy(src, sr, 8);
  return;
}

